# -*- coding: utf-8 -*-
"""BlackScholesEquation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H_QEI6HKhHESlsVC97ViRhAZ93swGAhv
"""

#Notebook for trying out the Black-Scholes Equation
#The idea here is that I only need O(log N) time, using N qubits to represent N grid points
#So the time taken to compute a multi-dimensional option goes from O(N^d) to O((log N)^d)


#Unfinished sadly
!pip install qiskit
!pip install qiskit_aer

from qiskit import QuantumCircuit, QuantumRegister
from qiskit_aer import Aer
import numpy as np

"""
Following the starter code.
"""
def compute_binomial_params(r, sigma, T, N):
    dt = T / N
    u = np.exp(sigma * np.sqrt(dt))
    d = np.exp(-sigma * np.sqrt(dt))
    p = (np.exp(r * dt) - d) / (u - d)
    return dt, u, d, p


def build_stock_tree(S0, u, d, N):
    tree = np.zeros((N + 1, N + 1))
    tree[0, 0] = S0

    for i in range(1, N + 1):
        tree[i, 0] = tree[i-1, 0] * u
        for j in range(1, i + 1):
            tree[i, j] = tree[i-1, j-1] * d

    return tree


def backward_induction(option_tree, p, r, dt, N):
    for i in range(N - 1, -1, -1):
        for j in range(i + 1):
            up_value = option_tree[i+1, j]
            down_value = option_tree[i+1, j+1]
            option_tree[i, j] = np.exp(-r * dt) * (p * up_value + (1 - p) * down_value)
    return option_tree[0, 0]

def create_binomial_circuit(p, N):
    qc = QuantumCircuit(N)
    theta = 2 * np.arcsin(np.sqrt(p))

    for q in range(N):
        qc.ry(theta, q)

    return qc


def simulate_circuit(qc):
    backend = Aer.get_backend('statevector_simulator')
    result = backend.run(qc).result()
    return result.get_statevector()


def calculate_terminal_price(state, S0, u, d, N):
    ups = bin(state).count('1')
    downs = N - ups
    return S0 * (u ** ups) * (d ** downs)


def quantum_call(S0, K, r, sigma, T, N):
    dt, u, d, p = compute_binomial_params(r, sigma, T, N)
    qc = create_binomial_circuit(p, N)
    statevector = simulate_circuit(qc)
    probs = np.abs(statevector) ** 2

    payoff = 0
    for state in range(2 ** N):
        S_T = calculate_terminal_price(state, S0, u, d, N)
        payoff += probs[state] * max(S_T - K, 0)

    return np.exp(-r * T) * payoff


def quantum_put(S0, K, r, sigma, T, N):
    dt, u, d, p = compute_binomial_params(r, sigma, T, N)
    qc = create_binomial_circuit(p, N)
    statevector = simulate_circuit(qc)
    probs = np.abs(statevector) ** 2

    payoff = 0
    for state in range(2 ** N):
        S_T = calculate_terminal_price(state, S0, u, d, N)
        payoff += probs[state] * max(K - S_T, 0)

    return np.exp(-r * T) * payoff

#####################
#### Simulations ####
#####################


S0 = 1
K = 1
r = 0.02
sigma = 0.2
T = 5
n_steps = 5
n_sim = 10000

results = {
    "Call Price": f"${quantum_call(S0, K, r, sigma, T, n_steps):.6f}",
    "Put Price": f"${quantum_put(S0, K, r, sigma, T, n_steps):.6f}"
}

print(results)

#params from the example code provided by IBM
#build comparison, see if i can extend this